# 브라운필드에서 작업하기: 완전한 가이드

> **강력히 권장: 브라운필드 문서 생성에 Gemini Web 또는 Gemini CLI를 사용하세요!**
>
> Gemini Web의 1M+ 토큰 컨텍스트 윈도우 또는 Gemini CLI(작동 중일 때)는 전체 코드베이스 또는 중요한 섹션을 한 번에 분석할 수 있습니다(물론 합리적인 범위 내에서):
>
> - GitHub URL을 통해 업로드하거나 프로젝트 폴더에서 gemini cli 사용
> - 웹에서 작업하는 경우: `npx bmad-method flatten`을 사용하여 프로젝트를 단일 파일로 플래튼한 다음, 해당 파일을 웹 에이전트에 업로드하세요.

## 브라운필드 개발이란?

브라운필드 개발은 기존 소프트웨어 프로젝트에 기능을 추가하거나, 버그를 수정하거나, 현대화하는 것을 의미합니다. 그린필드(새로운) 프로젝트와 달리, 브라운필드 작업은 기존 코드를 이해하고, 제약 사항을 존중하며, 기존 기능을 깨지 않고 새로운 변경 사항이 원활하게 통합되도록 하는 것이 필요합니다.

## 브라운필드에 BMad를 사용할 때

- 기존 애플리케이션에 중요한 새 기능 추가
- 레거시 코드베이스 현대화
- 새로운 기술이나 서비스 통합
- 복잡한 시스템 리팩토링
- 아키텍처적 이해가 필요한 버그 수정
- 문서화되지 않은 시스템 문서화

## 브라운필드 플로우를 사용하지 말아야 할 때

BMad로 MVP를 막 완료했고 MVP 이후를 계속하고 싶다면, PM과 대화하여 PRD에 추가할 새로운 에픽을 만들어달라고 요청하고, 에픽을 샤딩하고, 아키텍트와 함께 아키텍처 문서를 업데이트한 다음 그곳에서 시작하는 것이 더 쉽습니다.

## 완전한 브라운필드 워크플로우

1. **[사용자 가이드 - 설치](user-guide.md#installation) 단계를 따라 웹에서 에이전트를 설정하세요.**
2. **전체 코드베이스의 '플래튼된' 단일 파일 생성** 실행: `npx bmad-method flatten`

### 접근 방식 선택

#### 접근 방식 A: PRD 우선 (매우 크고 복잡한 새 기능, 단일 또는 다중 에픽 또는 대규모 변경을 추가하는 경우 권장)

**최적 용도**: 대규모 코드베이스, 모노레포 또는 정확히 무엇을 구축할지 알고 있을 때

1. **요구사항을 정의하기 위해 PRD를 먼저 생성**
2. **PRD 요구사항에 기반해 관련 영역만 문서화**
3. **더 효율적** - 사용하지 않는 코드 문서화를 피함

#### 접근 방식 B: 문서 우선 (소규모 프로젝트에 적합)

**최적 용도**: 소규모 코드베이스, 알려지지 않은 시스템 또는 탐색적 변경

1. **전체 시스템을 먼저 문서화**
2. **전체 컨텍스트로 PRD 생성**
3. **더 철저함** - 모든 것을 포착

### 접근 방식 A: PRD 우선 워크플로우 (권장)

#### 1단계: 요구사항을 먼저 정의

**Gemini Web에서 (플래튼된 codebase.xml 업로드 후):**

```bash
@pm
*create-brownfield-prd
```

PM이 수행할 작업:

- **향상 요구사항에 대해 질문**
- **현재 상태를 이해하기 위해 코드베이스 탐색**
- **문서화가 필요한 영향받는 영역 식별**
- **명확한 범위로 집중된 PRD 생성**

**핵심 장점**: PRD가 모노레포/대규모 코드베이스의 어떤 부분이 실제로 문서화가 필요한지 식별합니다!

#### 2단계: 집중된 문서화

**여전히 Gemini Web에서, 이제 PRD 컨텍스트와 함께:**

```bash
@architect
*document-project
```

아키텍트가 수행할 작업:

- **PRD가 제공되지 않은 경우 초점에 대해 질문**
- **옵션 제공**: PRD 생성, 요구사항 제공 또는 향상 기능 설명
- **범위를 이해하기 위해 PRD/설명 참조**
- **PRD 또는 설명에서 식별된 관련 모듈에 집중**
- **관련 없는 영역을 건너뛰어** 문서를 간결하게 유지
- **모든 환경에 대한 하나의 아키텍처 문서 생성**

아키텍트가 생성하는 것:

- **fullstack-architecture 템플릿을 따르는 하나의 포괄적인 아키텍처 문서**
- **단일 파일에서 모든 시스템 측면 커버**
- **`docs/architecture.md`로 복사하고 저장하기 쉬움**
- **원하는 경우 나중에 IDE에서 샤딩 가능**

예를 들어, "사용자 서비스에 결제 처리 추가"라고 말하면:

- 다음만 문서화: 사용자 서비스, API 엔드포인트, 데이터베이스 스키마, 결제 통합
- 결제 관련 코드 경로만 보여주는 집중된 소스 트리 생성
- 건너뛰는 것: 관리자 패널, 보고 모듈, 관련 없는 마이크로서비스

### 접근 방식 B: 문서 우선 워크플로우

#### 1단계: 기존 시스템 문서화

**최고 접근법 - 1M+ 컨텍스트를 가진 Gemini Web**:

1. **Gemini Web으로 이동** (gemini.google.com)
2. **프로젝트 업로드**:
   - **옵션 A**: GitHub 리포지토리 URL을 직접 붙여넣기
   - **옵션 B**: flattened-codebase.xml 파일 업로드
3. **아키텍트 에이전트 로드**: `dist/agents/architect.txt` 업로드
4. **문서화 실행**: `*document-project` 입력

아키텍트가 모든 것에 대한 포괄적인 문서를 생성할 것입니다.

#### 2단계: 향상 기능 계획

##### 옵션 A: 완전한 브라운필드 워크플로우 (주요 변경사항에 권장)

**1. 브라운필드 PRD 생성**:

```bash
@pm
*create-brownfield-prd
```

PM 에이전트가 수행할 작업:

- **1단계의 기존 문서 분석**
- **당신으로부터 특정 향상 세부사항 요청**
- **복잡성 평가** 및 접근법 권장
- **향상을 위한 에픽/스토리 구조 생성**
- **위험 및 통합 지점 식별**

**PM 에이전트가 프로젝트 컨텍스트를 얻는 방법**:

- Gemini Web에서: 이미 1단계 문서화에서 전체 프로젝트 컨텍스트 보유
- IDE에서: "기존 프로젝트 문서의 경로를 제공해주세요"라고 질문할 것

**마주하게 될 주요 프롬프트**:

- "어떤 특정 향상이나 기능을 추가하고 싶으신가요?"
- "이것이 통합해야 할 기존 시스템이나 API가 있나요?"
- "우리가 존중해야 할 중요한 제약사항은 무엇인가요?"
- "타임라인과 팀 규모는 어떻게 되나요?"

**2. 브라운필드 아키텍처 생성**:

```bash
@architect
*create-brownfield-architecture
```

아키텍트가 수행할 작업:

- **브라운필드 PRD 검토**
- **통합 전략 설계**
- **필요시 마이그레이션 접근법 계획**
- **기술적 위험 식별**
- **호환성 요구사항 정의**

##### 옵션 B: 빠른 향상 (집중된 변경을 위한)

**전체 PRD 없이 단일 에픽을 위한**:

```bash
@pm
*create-brownfield-epic
```

다음과 같은 경우 사용:

- 향상이 잘 정의되고 격리되어 있음
- 기존 문서가 포괄적임
- 변경이 여러 시스템에 영향을 주지 않음
- 빠른 처리가 필요함

**단일 스토리를 위한**:

```bash
@pm
*create-brownfield-story
```

다음과 같은 경우 사용:

- 버그 수정이나 작은 기능
- 매우 격리된 변경
- 아키텍처적 영향 없음
- 명확한 구현 경로

### 3단계: 계획 산출물 검증

```bash
@po
*execute-checklist-po
```

PO가 다음을 보장합니다:

- 기존 시스템과의 호환성
- 계획된 파괴적 변경사항 없음
- 위험 완화 전략 마련
- 명확한 통합 접근법

### 4단계: 문서 저장 및 샤딩

1. PRD와 아키텍처를 다음과 같이 저장:
   docs/prd.md
   docs/architecture.md
   (참고: 여러 버전을 관리하는 경우 선택적으로 'brownfield-' 접두사 사용 가능)
2. 문서 샤딩:
   IDE에서

   ```bash
   @po
   shard docs/prd.md
   ```

   ```bash
   @po
   shard docs/architecture.md
   ```

### 5단계: 개발로 전환

**[향상된 IDE 개발 워크플로우](enhanced-ide-development-workflow.md)를 따르세요**

## 브라운필드 모범 사례

### 1. 항상 먼저 문서화

코드베이스를 안다고 생각하더라도:

- `document-project`를 실행하여 현재 상태 캡처
- AI 에이전트에게 이 컨텍스트가 필요함
- 문서화되지 않은 패턴 발견

### 2. 기존 패턴 존중

브라운필드 템플릿은 특별히 다음을 찾습니다:

- 현재 코딩 관례
- 기존 아키텍처 패턴
- 기술적 제약사항
- 팀 선호도

### 3. 점진적 롤아웃 계획

브라운필드 변경은 다음을 해야 합니다:

- 기능 플래그 지원
- 롤백 전략 계획
- 마이그레이션 스크립트 포함
- 하위 호환성 유지

### 4. 통합 철저히 테스트

#### 브라운필드에서 테스트 아키텍트가 중요한 이유

브라운필드 프로젝트에서 테스트 아키텍트(Quinn)는 기존 기능을 파괴하는 것에 대한 안전망이 됩니다. 새로 구축하는 그린필드와 달리, 브라운필드는 새로운 변경사항이 이미 작동하는 것을 불안정하게 만들지 않도록 신중한 검증이 필요합니다.

#### 브라운필드별 테스트 과제

테스트 아키텍트는 고유한 브라운필드 복잡성을 해결합니다:

| **과제**               | **테스트 아키텍트의 도움**                      | **명령**         |
| --------------------------- | ------------------------------------------------- | ------------------- |
| **회귀 위험**        | 어떤 기존 기능이 깨질 수 있는지 식별    | `*risk`             |
| **레거시 의존성**     | 통합 지점과 숨겨진 의존성 매핑   | `*trace`            |
| **성능 저하** | 기존 플로우에서 속도 저하가 없는지 검증           | `*nfr`              |
| **커버리지 갭**           | 새 변경사항이 건드리는 테스트되지 않은 레거시 코드 찾기 | `*design`           |
| **파괴적 변경**        | API/계약 위반 감지                   | `*review`           |
| **마이그레이션 안전성**        | 데이터 변환 및 롤백 계획 검증 | `*risk` + `*review` |

#### 브라운필드를 위한 완전한 테스트 아키텍트 워크플로우

##### 1단계: 개발 전 (위험 및 전략)

**브라운필드에서 중요 - 이것들을 먼저 실행하세요:**

```bash
# 1. 위험 평가 (스토리 생성 후 즉시 실행)
@qa *risk {brownfield-story}
# 식별: 레거시 의존성, 파괴적 변경, 통합 지점
# 출력: docs/qa/assessments/{epic}.{story}-risk-{YYYYMMDD}.md
# 브라운필드 중점:
#   - 회귀 확률 점수
#   - 영향받는 다운스트림 시스템
#   - 데이터 마이그레이션 위험
#   - 롤백 복잡성

# 2. 테스트 설계 (위험 평가 후)
@qa *design {brownfield-story}
# 생성: 회귀 테스트 전략 + 새 기능 테스트
# 출력: docs/qa/assessments/{epic}.{story}-test-design-{YYYYMMDD}.md
# 브라운필드 중점:
#   - 회귀 테스트가 필요한 기존 기능
#   - 통합 테스트 요구사항
#   - 유지해야 할 성능 벤치마크
#   - 기능 플래그 테스트 시나리오
```

##### 2단계: 개발 중 (지속적 검증)

**코딩하는 동안 통합 상태 모니터링:**

```bash
# 3. 요구사항 추적 (개발 중간 체크포인트)
@qa *trace {brownfield-story}
# 매핑: 새 요구사항 + 기존 기능 보존
# 출력: docs/qa/assessments/{epic}.{story}-trace-{YYYYMMDD}.md
# 브라운필드 중점:
#   - 여전히 작동해야 하는 기존 기능
#   - 새/기존 기능 상호작용
#   - API 계약 보존
#   - 누락된 회귀 테스트 커버리지

# 4. NFR 검증 ("완료"로 간주하기 전)
@qa *nfr {brownfield-story}
# 검증: 성능, 보안, 신뢰성이 변경되지 않음
# 출력: docs/qa/assessments/{epic}.{story}-nfr-{YYYYMMDD}.md
# 브라운필드 중점:
#   - 성능 회귀 감지
#   - 통합의 보안 함의
#   - 하위 호환성 검증
#   - 레거시 구성요소에 대한 부하/스트레스
```

##### 3단계: 코드 리뷰 (심층 통합 분석)

**포괄적 브라운필드 리뷰:**

```bash
# 5. 전체 리뷰 (개발 완료 시)
@qa *review {brownfield-story}
# 수행: 심층 분석 + 적극적 리팩토링
# 출력:
#   - 스토리 파일의 QA 결과
#   - 게이트 파일: docs/qa/gates/{epic}.{story}-{slug}.yml
```

리뷰는 특별히 다음을 분석합니다:

- **API 파괴적 변경**: 모든 기존 계약이 유지되는지 검증
- **데이터 마이그레이션 안전성**: 변환 로직 및 롤백 절차 확인
- **성능 회귀**: 기준 메트릭과 비교
- **통합 지점**: 레거시 코드와의 모든 접점 검증
- **기능 플래그 로직**: 적절한 토글 동작 보장
- **의존성 영향**: 영향받는 다운스트림 시스템 매핑

##### 4단계: 리뷰 후 (게이트 업데이트)

```bash
# 6. 게이트 상태 업데이트 (이슈 해결 후)
@qa *gate {brownfield-story}
# 업데이트: 수정 후 품질 게이트 결정
# 출력: docs/qa/gates/{epic}.{story}-{slug}.yml
# 브라운필드 고려사항:
#   - 특정 레거시 코드 이슈 면제 가능
#   - 기술 부채 수용 문서화
#   - 마이그레이션 진행 상황 추적
```

#### 브라운필드별 위험 점수 매기기

테스트 아키텍트는 브라운필드를 위한 향상된 위험 점수를 사용합니다:

| **위험 카테고리**      | **브라운필드 요소**                     | **게이트에 미치는 영향**  |
| ---------------------- | ------------------------------------------ | ------------------- |
| **회귀 위험**    | 통합 지점 수 × 코드 연령 | 점수 ≥9 = 실패     |
| **데이터 위험**          | 마이그레이션 복잡성 × 데이터 볼륨         | 점수 ≥6 = 우려사항 |
| **성능 위험**   | 현재 부하 × 추가된 복잡성            | 점수 ≥6 = 우려사항 |
| **호환성 위험** | API 소비자 수 × 계약 변경사항           | 점수 ≥9 = 실패     |

#### 브라운필드 테스팅 표준

Quinn은 브라운필드를 위한 추가 표준을 적용합니다:

- **회귀 테스트 커버리지**: 수정된 모든 레거시 모듈에 테스트 필요
- **성능 기준선**: 현재 메트릭을 유지하거나 개선해야 함
- **롤백 절차**: 모든 변경사항에 롤백 계획 필요
- **기능 플래그**: 모든 위험한 변경사항은 토글 뒤에 배치
- **통합 테스트**: 모든 레거시 접점 커버
- **계약 테스트**: API 호환성 검증
- **데이터 검증**: 마이그레이션 정확성 검사

#### 빠른 참조: 브라운필드 테스트 명령

| **시나리오**                      | **실행할 명령**                                  | **순서**  | **중요한 이유**              |
| --------------------------------- | ---------------------------------------------------- | ---------- | ----------------------------- |
| **레거시 코드에 기능 추가** | `*risk` → `*design` → `*trace` → `*review`           | 순차적 | 모든 의존성을 먼저 매핑    |
| **API 수정**              | `*risk` → `*design` → `*nfr` → `*review`             | 순차적 | 소비자 손상 방지    |
| **성능에 중요한 변경**   | `*nfr` 자주 실행 → `*review`                   | 지속적 | 즉시 성능 저하 감지 |
| **데이터 마이그레이션**                | `*risk` → `*design` → `*trace` → `*review` → `*gate` | 전체 사이클 | 데이터 무결성 보장         |
| **복잡한 시스템에서 버그 수정**     | `*risk` → `*trace` → `*review`                       | 집중적 | 부작용 방지          |

#### 브라운필드 시나리오와의 통합

**시나리오별 가이드:**

1. **레거시 코드 현대화**
   - `*risk`로 시작하여 모든 의존성 매핑
   - `*design`을 사용하여 스트랭글러 피그 접근법 계획
   - `*trace`를 자주 실행하여 아무것도 깨지지 않도록 보장
   - 점진적 마이그레이션에 중점을 둔 `*review`

2. **모노리스에 기능 추가**
   - `*risk`가 통합 복잡성 식별
   - `*design`이 격리 전략 계획
   - `*nfr`이 성능 영향 모니터링
   - `*review`가 모노리스 저하 없음 검증

3. **마이크로서비스 추출**
   - `*risk`가 서비스 경계 매핑
   - `*trace`가 기능 보존 보장
   - `*nfr`이 네트워크 오버헤드가 허용 가능한지 검증
   - `*gate`가 받아들인 트레이드오프 문서화

4. **데이터베이스 스키마 변경**
   - `*risk`가 마이그레이션 복잡성 평가
   - `*design`이 하위 호환성 접근법 계획
   - `*trace`가 영향받는 모든 쿼리 매핑
   - `*review`가 마이그레이션 안전성 검증

### 5. 변경사항 소통

다음을 문서화:

- 무엇이 변경되었고 왜 변경되었는지
- 마이그레이션 지침
- 도입된 새로운 패턴
- 사용 중단 공지

## 일반적인 브라운필드 시나리오

### 시나리오 1: 새로운 기능 추가

1. 기존 시스템 문서화
2. 통합에 중점을 둔 브라운필드 PRD 생성
3. **테스트 아키텍트 조기 참여**:
   - 초안 스토리에서 `@qa *risk`를 실행하여 통합 위험 식별
   - `@qa *design`을 사용하여 회귀 테스트 전략 계획
4. 아키텍처는 호환성 강조
5. 스토리에 테스트 요구사항이 포함된 통합 작업 포함
6. **개발 중**:
   - 개발자가 `@qa *trace`를 실행하여 커버리지 검증
   - `@qa *nfr`을 사용하여 성능 영향 모니터링
7. **리뷰 단계**: `@qa *review`가 통합 안전성 검증

### 시나리오 2: 레거시 코드 현대화

1. 광범위한 문서화 단계
2. PRD에 마이그레이션 전략 포함
3. **테스트 아키텍트 전략 계획**:
   - `@qa *risk`가 현대화 복잡성 평가
   - `@qa *design`이 병렬 테스팅 접근법 계획
4. 아키텍처가 점진적 전환 계획 (스트랭글러 피그 패턴)
5. 스토리는 다음과 함께 점진적 현대화를 따름:
   - 건드리지 않은 레거시 코드를 위한 회귀 테스트
   - 새로운/기존 경계를 위한 통합 테스트
   - 각 단계에서의 성능 벤치마크
6. **지속적 검증**: 각 증분 후 `@qa *trace` 실행
7. **게이트 관리**: `@qa *gate`를 사용하여 기술 부채 수용 추적

### 시나리오 3: 복잡한 시스템에서 버그 수정

1. 관련 하위 시스템 문서화
2. 집중적 수정을 위해 `create-brownfield-story` 사용
3. **테스트 아키텍트 위험 평가**: `@qa *risk`를 실행하여 부작용 가능성 식별
4. `@qa *design` 출력에서 회귀 테스트 요구사항 포함
5. **수정 중**: `@qa *trace`를 사용하여 영향받는 기능 매핑
6. **커밋 전**: 포괄적 검증을 위해 `@qa *review` 실행
7. 테스트 아키텍트가 다음을 사용하여 부작용 없음 검증:
   - 부작용 분석을 위한 위험 프로파일링 (확률 × 영향 점수)
   - 수정이 관련 기능을 깨지 않도록 보장하는 추적 매트릭스
   - 성능/보안이 변경되지 않았는지 검증하는 NFR 평가
   - 수정 안전성을 문서화하는 게이트 결정

### 시나리오 4: API 통합

1. 기존 API 패턴 문서화
2. PRD가 통합 요구사항 정의
3. **테스트 아키텍트 계약 분석**:
   - `@qa *risk`가 파괴적 변경 가능성 식별
   - `@qa *design`이 계약 테스트 전략 생성
4. 아키텍처가 일관된 패턴 보장
5. **API 테스팅 중점**:
   - 하위 호환성을 위한 계약 테스트
   - 새 엔드포인트를 위한 통합 테스트
   - 추가 부하를 위한 성능 테스트
6. 스토리에 API 문서 업데이트 포함
7. **검증 체크포인트**:
   - `@qa *trace`가 모든 API 소비자 매핑
   - `@qa *nfr`이 응답 시간 검증
   - `@qa *review`가 파괴적 변경 없음 보장
8. **게이트 결정**: 마이그레이션 경로와 함께 수용된 파괴적 변경사항 문서화

## 문제 해결

### "AI가 내 코드베이스를 이해하지 못함"

**해결책**: 중요한 파일들에 대한 더 구체적인 경로로 `document-project`를 다시 실행

### "생성된 계획이 우리 패턴에 맞지 않음"

**해결책**: 계획 단계 전에 생성된 문서를 특정 관례로 업데이트

### "작은 변경사항에 너무 많은 보일러플레이트"

**해결책**: 전체 워크플로우 대신 `create-brownfield-story` 사용

### "통합 지점이 불명확"

**해결책**: PRD 생성 중에 통합 시스템을 구체적으로 강조하여 더 많은 컨텍스트 제공

## 빠른 참조

### 브라운필드별 명령

```bash
# 기존 프로젝트 문서화
@architect *document-project

# 향상 PRD 생성
@pm *create-brownfield-prd

# 통합에 중점을 둔 아키텍처 생성
@architect *create-brownfield-architecture

# 빠른 에픽 생성
@pm *create-brownfield-epic

# 단일 스토리 생성
@pm *create-brownfield-story
```

### 브라운필드를 위한 테스트 아키텍트 명령

참고: 아래는 축약형. 전체 명령: `*risk-profile`, `*test-design`, `*nfr-assess`, `*trace-requirements`

```bash
# 개발 전 (계획)
@qa *risk {story}     # 회귀 및 통합 위험 평가
@qa *design {story}   # 회귀 + 새 기능 테스트 계획

# 개발 중 (검증)
@qa *trace {story}    # 기존 + 새로운 것의 커버리지 검증
@qa *nfr {story}      # 성능 저하 확인

# 개발 후 (리뷰)
@qa *review {story}   # 심층 통합 분석
@qa *gate {story}     # 품질 결정 업데이트
```

### 의사결정 트리

```text
대규모 코드베이스나 모노레포를 가지고 있나요?
├─ Yes → PRD 우선 접근법
│   └─ PRD 생성 → 영향받는 영역만 문서화
└─ No → 코드베이스를 잘 알고 있나요?
    ├─ Yes → PRD 우선 접근법
    └─ No → 문서 우선 접근법

이것이 여러 시스템에 영향을 주는 주요 향상인가요?
├─ Yes → 완전한 브라운필드 워크플로우
│   └─ 항상 테스트 아키텍트 *risk + *design을 먼저 실행
└─ No → 이것이 단순한 버그 수정 이상인가요?
    ├─ Yes → *create-brownfield-epic
    │   └─ 통합 지점을 위해 테스트 아키텍트 *risk 실행
    └─ No → *create-brownfield-story
        └─ 중요한 경로를 건드리는 경우 여전히 *risk 실행

변경사항이 레거시 코드를 건드리나요?
├─ Yes → 테스트 아키텍트는 필수
│   ├─ *risk → 회귀 가능성 식별
│   ├─ *design → 테스트 커버리지 계획
│   └─ *review → 손상 없음 검증
└─ No → 테스트 아키텍트는 권장
    └─ *review → 품질 표준 보장
```

## 결론

BMad Method를 사용한 브라운필드 개발은 기존 시스템을 수정할 때 구조와 안전성을 제공합니다. 테스트 아키텍트는 위험 평가, 회귀 테스팅, 지속적 검증을 사용하여 새로운 변경사항이 기존 기능을 불안정하게 만들지 않도록 보장하는 중요한 안전망이 됩니다.

**브라운필드 성공 공식:**

1. **먼저 문서화** - 무엇이 존재하는지 이해
2. **조기 위험 평가** - 코딩 전에 테스트 아키텍트 `*risk` 사용
3. **테스트 전략 계획** - 회귀 + 새 기능 테스트 설계
4. **지속적 검증** - 개발 중 통합 상태 확인
5. **포괄적 리뷰** - 커밋 전 심층 분석
6. **결정적 게이트** - 품질 결정 문서화

기억하세요: **브라운필드에서 테스트 아키텍트는 선택 사항이 아닙니다 - 프로덕션 손상에 대한 보험 정책입니다.**
