<!-- Powered by BMAD™ Core -->

# 아키텍트 솔루션 검증 체크리스트

이 체크리스트는 아키텍트가 개발 실행 전에 기술 설계와 아키텍처를 검증하기 위한 포괄적인 프레임워크 역할을 합니다. 아키텍트는 각 항목을 체계적으로 검토하여 아키텍처가 견고하고, 확장 가능하며, 안전하고, 제품 요구사항과 일치하는지 확인해야 합니다.

[[LLM: 초기화 지시사항 - 필수 아티팩트

이 체크리스트를 진행하기 전에 다음에 대한 접근 권한이 있는지 확인하세요:

1. architecture.md - 주요 아키텍처 문서 (docs/architecture.md 확인)
2. prd.md - 요구사항 정렬을 위한 제품 요구사항 문서 (docs/prd.md 확인)
3. frontend-architecture.md 또는 fe-architecture.md - UI 프로젝트인 경우 (docs/frontend-architecture.md 확인)
4. 아키텍처에서 참조되는 모든 시스템 다이어그램
5. 사용 가능한 경우 API 문서
6. 기술 스택 세부사항 및 버전 사양

중요: 필요한 문서가 누락되거나 접근할 수 없는 경우, 진행하기 전에 즉시 사용자에게 해당 위치나 내용을 요청하세요.

프로젝트 유형 감지:
먼저 다음을 확인하여 프로젝트 유형을 결정하세요:

- 아키텍처에 프론트엔드/UI 구성 요소가 포함되어 있나요?
- frontend-architecture.md 문서가 있나요?
- PRD에서 사용자 인터페이스나 프론트엔드 요구사항을 언급하나요?

백엔드 전용 또는 서비스 전용 프로젝트인 경우:

- [[FRONTEND ONLY]]로 표시된 섹션을 건너뛰세요
- API 설계, 서비스 아키텍처, 통합 패턴에 특별한 주의를 기울이세요
- 최종 보고서에서 프로젝트 유형으로 인해 프론트엔드 섹션을 건너뛰었다고 기록하세요

검증 접근 방식:
각 섹션에 대해 다음을 수행해야 합니다:

1. 심층 분석 - 단순히 체크박스를 확인하지 말고, 제공된 문서와 대조하여 각 항목을 철저히 분석하세요
2. 증거 기반 - 검증할 때 문서의 특정 섹션이나 인용문을 인용하세요
3. 비판적 사고 - 가정에 의문을 제기하고 단순히 현재 있는 것을 확인하는 것이 아니라 격차를 식별하세요
4. 위험 평가 - 각 아키텍처 결정에서 무엇이 잘못될 수 있는지 고려하세요

실행 모드:
사용자에게 체크리스트를 다음과 같이 진행할지 물어보세요:

- 섹션별 (인터랙티브 모드) - 각 섹션을 검토하고, 결과를 제시하고, 진행하기 전에 확인을 받으세요
- 한 번에 모두 (포괄적 모드) - 전체 분석을 완료하고 마지막에 포괄적인 보고서를 제시하세요]]

## 1. 요구사항 정렬

[[LLM: 이 섹션을 평가하기 전에 PRD에서 제품의 목적과 목표를 완전히 이해하는 시간을 가지세요. 해결되는 핵심 문제는 무엇인가요? 사용자는 누구인가요? 중요한 성공 요인은 무엇인가요? 정렬을 검증할 때 이를 염두에 두세요. 각 항목에 대해 단순히 언급되었는지 확인하지 말고 아키텍처가 구체적인 기술 솔루션을 제공하는지 확인하세요.]]

### 1.1 기능 요구사항 커버리지

- [ ] 아키텍처가 PRD의 모든 기능 요구사항을 지원함
- [ ] 모든 에픽과 스토리에 대한 기술적 접근 방식이 다뤄짐
- [ ] 엣지 케이스와 성능 시나리오가 고려됨
- [ ] 모든 필요한 통합이 고려됨
- [ ] 사용자 여정이 기술 아키텍처에 의해 지원됨

### 1.2 비기능 요구사항 정렬

- [ ] 성능 요구사항이 특정 솔루션으로 다뤄짐
- [ ] 확장성 고려사항이 접근 방식과 함께 문서화됨
- [ ] 보안 요구사항에 해당하는 기술적 제어가 있음
- [ ] 신뢰성과 회복력 접근 방식이 정의됨
- [ ] 컴플라이언스 요구사항에 기술적 구현이 있음

### 1.3 기술적 제약 준수

- [ ] PRD의 모든 기술적 제약이 만족됨
- [ ] 플랫폼/언어 요구사항이 준수됨
- [ ] 인프라 제약이 수용됨
- [ ] 서드파티 서비스 제약이 다뤄짐
- [ ] 조직의 기술 표준이 준수됨

## 2. 아키텍처 기본사항

[[LLM: 아키텍처 명확성은 성공적인 구현에 중요합니다. 이 섹션을 검토할 때, 새로운 개발자에게 설명하는 것처럼 시스템을 시각화하세요. 잘못된 해석을 초래할 수 있는 모호함이 있나요? AI 에이전트가 혼란 없이 이 아키텍처를 구현할 수 있을까요? 특정 다이어그램, 구성 요소 정의, 명확한 상호작용 패턴을 찾으세요.]]

### 2.1 아키텍처 명확성

- [ ] 아키텍처가 명확한 다이어그램으로 문서화됨
- [ ] 주요 구성 요소와 그 책임이 정의됨
- [ ] 구성 요소 상호작용과 종속성이 매핑됨
- [ ] 데이터 흐름이 명확히 설명됨
- [ ] 각 구성 요소의 기술 선택이 명시됨

### 2.2 관심사 분리

- [ ] UI, 비즈니스 로직, 데이터 계층 간의 명확한 경계
- [ ] 구성 요소 간 책임이 깔끔하게 분할됨
- [ ] 구성 요소 간 인터페이스가 잘 정의됨
- [ ] 구성 요소가 단일 책임 원칙을 준수함
- [ ] 횡단 관심사(로깅, 인증 등)가 적절히 다뤄짐

### 2.3 디자인 패턴 & 모범 사례

- [ ] 적절한 디자인 패턴이 사용됨
- [ ] 업계 모범 사례가 준수됨
- [ ] 안티 패턴이 피해짐
- [ ] 전체적으로 일관된 아키텍처 스타일
- [ ] 패턴 사용이 문서화되고 설명됨

### 2.4 모듈성 & 유지보수성

- [ ] 시스템이 응집력 있고 느슨하게 결합된 모듈로 분할됨
- [ ] 구성 요소가 독립적으로 개발되고 테스트될 수 있음
- [ ] 변경사항이 특정 구성 요소로 국한될 수 있음
- [ ] 코드 조직이 발견가능성을 촉진함
- [ ] AI 에이전트 구현을 위해 특별히 설계된 아키텍처

## 3. 기술 스택 & 결정사항

[[LLM: 기술 선택은 장기적인 영향을 미칩니다. 각 기술 결정에 대해 고려하세요: 이것이 작동할 수 있는 가장 간단한 솔루션인가요? 과도하게 엔지니어링하고 있나요? 이것이 확장될까요? 유지보수 영향은 무엇인가요? 선택된 버전에 보안 취약점이 있나요? 범위가 아닌 특정 버전이 정의되었는지 확인하세요.]]

### 3.1 기술 선택

- [ ] 선택된 기술이 모든 요구사항을 충족함
- [ ] 기술 버전이 구체적으로 정의됨 (범위가 아님)
- [ ] 기술 선택이 명확한 근거로 정당화됨
- [ ] 고려된 대안이 장단점과 함께 문서화됨
- [ ] 선택된 스택 구성 요소가 잘 함께 작동함

### 3.2 프론트엔드 아키텍처 [[FRONTEND ONLY]]

[[LLM: 백엔드 전용 또는 서비스 전용 프로젝트인 경우 이 전체 섹션을 건너뛰세요. 프로젝트에 사용자 인터페이스가 포함된 경우에만 평가하세요.]]

- [ ] UI 프레임워크와 라이브러리가 구체적으로 선택됨
- [ ] 상태 관리 접근 방식이 정의되고 정당화됨
- [ ] 스타일링 접근 방식이 명확히 설명됨
- [ ] 프론트엔드 라우팅 전략이 다뤄짐
- [ ] 빌드와 번들링 프로세스가 정의됨
- [ ] API와의 통신 패턴이 명시됨

### 3.3 백엔드 아키텍처

- [ ] 서버 프레임워크와 런타임이 선택되고 정당화됨
- [ ] 데이터베이스 선택이 요구사항과 일치함
- [ ] API 설계 접근 방식이 명확함 (REST, GraphQL, etc.)
- [ ] 인증 및 권한 부여 전략이 정의됨
- [ ] 서버 측 상태 관리 접근 방식이 명시됨

### 3.4 인프라 및 배포

- [ ] 호스팅 플랫폼이 요구사항에 맞게 선택됨
- [ ] 배포 전략이 정의됨
- [ ] 환경 관리 접근 방식이 명확함
- [ ] 확장성 요구사항이 인프라 계획에 반영됨
- [ ] 재해 복구와 백업 전략이 고려됨

## 4. 프론트엔드 설계 & 구현 [[FRONTEND ONLY]]

[[LLM: 백엔드 전용 프로젝트인 경우 이 전체 섹션을 건너뛰어야 합니다. 프로젝트에 사용자 인터페이스가 포함된 경우에만 평가하세요. 평가할 때, 주요 아키텍처 문서와 프론트엔드 특정 아키텍처 문서 간의 정렬을 보장하세요.]]

### 4.1 프론트엔드 철학 & 패턴

- [ ] 프레임워크 & 핵심 라이브러리가 주요 아키텍처 문서와 일치함
- [ ] 컴포넌트 아키텍처 (예: Atomic Design)가 명확히 설명됨
- [ ] 상태 관리 전략이 애플리케이션 복잡성에 적합함
- [ ] 데이터 흐름 패턴이 일관되고 명확함
- [ ] 스타일링 접근 방식이 정의되고 툴링이 명시됨

### 4.2 프론트엔드 구조 & 조직

- [ ] 디렉토리 구조가 ASCII 다이어그램으로 명확히 문서화됨
- [ ] 컴포넌트 조직이 명시된 패턴을 따름
- [ ] 파일 명명 규칙이 명시적임
- [ ] 구조가 선택된 프레임워크의 모범 사례를 지원함
- [ ] 새로운 컴포넌트를 어디에 배치해야 하는지에 대한 명확한 가이드

### 4.3 컴포넌트 설계

- [ ] 컴포넌트 템플릿/사양 형식이 정의됨
- [ ] 컴포넌트 props, state, events가 잘 문서화됨
- [ ] 공유/기초 컴포넌트가 식별됨
- [ ] 컴포넌트 재사용 패턴이 확립됨
- [ ] 접근성 요구사항이 컴포넌트 설계에 내장됨

### 4.4 프론트엔드-백엔드 통합

- [ ] API 상호작용 계층이 명확히 정의됨
- [ ] HTTP 클라이언트 설정 및 구성이 문서화됨
- [ ] API 호출에 대한 오류 처리가 포괄적임
- [ ] 서비스 정의가 일관된 패턴을 따름
- [ ] 백엔드와의 인증 통합이 명확함

### 4.5 라우팅 & 내비게이션

- [ ] 라우팅 전략과 라이브러리가 명시됨
- [ ] 라우트 정의 테이블이 포괄적임
- [ ] 라우트 보호 메커니즘이 정의됨
- [ ] 딥 링킹 고려사항이 다뤄짐
- [ ] 내비게이션 패턴이 일관됨

### 4.6 프론트엔드 성능

- [ ] 이미지 최적화 전략이 정의됨
- [ ] 코드 분할 접근 방식이 문서화됨
- [ ] 지연 로딩 패턴이 확립됨
- [ ] 재렌더링 최적화 기법이 명시됨
- [ ] 성능 모니터링 접근 방식이 정의됨

## 5. 복원력 & 운영 준비성

[[LLM: 프로덕션 시스템은 예상치 못한 방식으로 실패합니다. 이 섹션을 검토할 때, 머피의 법칙을 생각하세요 - 무엇이 잘못될 수 있나요? 실제 시나리오를 고려하세요: 피크 로드 시에는 어떻게 될까요? 중요한 서비스가 다운될 때 시스템이 어떻게 동작하나요? 운영 팀이 새벽 3시에 문제를 진단할 수 있나요? 단순히 "오류 처리"를 언급하는 것이 아니라 구체적인 복원력 패턴을 찾으세요.]]

### 5.1 오류 처리 & 복원력

- [ ] 오류 처리 전략이 포괄적임
- [ ] 재시도 정책이 적절한 곳에서 정의됨
- [ ] 중요한 서비스에 대해 서킷 브레이커나 폴백이 명시됨
- [ ] 우아한 성능 저하 접근 방식이 정의됨
- [ ] 시스템이 부분적 실패로부터 복구할 수 있음

### 5.2 모니터링 & 관찰가능성

- [ ] 로깅 전략이 정의됨
- [ ] 모니터링 접근 방식이 명시됨
- [ ] 시스템 상태에 대한 주요 메트릭이 식별됨
- [ ] 경고 임계값과 전략이 개요화됨
- [ ] 디버깅과 문제 해결 기능이 내장됨

### 5.3 성능 & 확장성

- [ ] 성능 병목 지점이 식별되고 다뤄짐
- [ ] 캐싱 전략이 적절한 곳에서 정의됨
- [ ] 로드 밸런싱 접근 방식이 명시됨
- [ ] 수평 및 수직 확장 전략이 개요화됨
- [ ] 리소스 크기 조정 권장사항이 제공됨

### 5.4 배포 & DevOps

- [ ] 배포 전략이 정의됨
- [ ] CI/CD 파이프라인 접근 방식이 개요화됨
- [ ] 환경 전략 (dev, staging, prod)이 명시됨
- [ ] Infrastructure as Code 접근 방식이 정의됨
- [ ] 롤백 및 복구 절차가 개요화됨

## 4. 보안 & 컴플라이언스

[[LLM: 보안은 시나리오와 위협을 구체적으로 식별해야 합니다. 방어 심화 접근 방식을 찾으세요. 컴플라이언스는 특정 요구사항과 구체적인 구현을 포함해야 합니다. 일반적인 보안 문제뿐만 아니라 이 특정 시스템의 데이터 흐름과 사용자 상호작용에 특정한 위험을 고려하세요.]]

### 4.1 보안 기본사항

- [ ] 인증 메커니즘이 명확히 정의되고 구현됨
- [ ] 권한 부여와 역할 기반 액세스 제어가 다뤄짐
- [ ] 데이터 암호화 (전송 중 및 저장 중)가 구현됨
- [ ] 입력 검증과 살균 전략이 정의됨
- [ ] 보안 헤더와 CORS 정책이 구성됨

### 4.2 위협 모델링

- [ ] 잠재적 보안 위협이 식별되고 평가됨
- [ ] 공격 벡터가 분석되고 완화됨
- [ ] 사용자 데이터 처리가 안전하게 설계됨
- [ ] API 보안 고려사항이 다뤄짐
- [ ] 서드파티 통합 보안이 평가됨

### 4.3 데이터 프라이버시

- [ ] 데이터 수집 및 저장 관행이 정의됨
- [ ] 개인 식별 정보(PII) 처리가 적절히 다뤄짐
- [ ] 데이터 보존 및 삭제 정책이 구현됨
- [ ] 사용자 동의 메커니즘이 고려됨 (필요한 경우)
- [ ] 데이터 익명화/가명화 접근 방식이 정의됨

### 4.4 컴플라이언스 요구사항

- [ ] 관련 규정 준수 요구사항이 식별됨 (GDPR, HIPAA, etc.)
- [ ] 컴플라이언스를 위한 특정 기술적 제어가 구현됨
- [ ] 감사 및 로깅 요구사항이 다뤄짐
- [ ] 데이터 지역성 요구사항이 고려됨
- [ ] 컴플라이언스 모니터링 및 보고가 계획됨

## 7. 구현 가이던스

[[LLM: 명확한 구현 가이던스는 비용이 많이 드는 실수를 방지합니다. 이 섹션을 검토할 때, 첫날 시작하는 개발자라고 상상해보세요. 생산적이 되기 위해 필요한 모든 것이 있나요? 코딩 표준이 팀 전체에서 일관성을 유지할 수 있을 만큼 명확한가요? 구체적인 예시와 패턴을 찾으세요.]]

### 7.1 코딩 표준 & 관행

- [ ] 코딩 표준이 정의됨
- [ ] 문서화 요구사항이 명시됨
- [ ] 테스팅 기대치가 개요화됨
- [ ] 코드 조직 원칙이 정의됨
- [ ] 명명 규칙이 명시됨

### 7.2 테스팅 전략

- [ ] 단위 테스트 접근 방식이 정의됨
- [ ] 통합 테스트 전략이 개요화됨
- [ ] E2E 테스트 접근 방식이 명시됨
- [ ] 성능 테스트 요구사항이 개요화됨
- [ ] 보안 테스트 접근 방식이 정의됨

### 7.3 프론트엔드 테스팅 [[FRONTEND ONLY]]

[[LLM: 백엔드 전용 프로젝트인 경우 이 하위 섹션을 건너뛰세요.]]

- [ ] 컴포넌트 테스트 범위와 도구가 정의됨
- [ ] UI 통합 테스트 접근 방식이 명시됨
- [ ] 시각적 회귀 테스트가 고려됨
- [ ] 접근성 테스트 도구가 식별됨
- [ ] 프론트엔드 특정 테스트 데이터 관리가 다뤄짐

### 7.4 개발 환경

- [ ] 로컬 개발 환경 설정이 문서화됨
- [ ] 필요한 도구와 구성이 명시됨
- [ ] 개발 워크플로우가 개요화됨
- [ ] 소스 제어 관행이 정의됨
- [ ] 종속성 관리 접근 방식이 명시됨

### 7.5 기술 문서화

- [ ] API 문서화 표준이 정의됨
- [ ] 아키텍처 문서화 요구사항이 명시됨
- [ ] 코드 문서화 기대치가 개요화됨
- [ ] 시스템 다이어그램과 시각화가 포함됨
- [ ] 주요 선택에 대한 의사결정 기록이 포함됨

## 8. 종속성 & 통합 관리

[[LLM: 종속성은 종종 프로덕션 문제의 원인입니다. 각 종속성에 대해 고려하세요: 사용할 수 없으면 어떻게 될까요? 보안 패치가 있는 새 버전이 있나요? 벤더에 묶여 있나요? 비상 계획은 무엇인가요? 구체적인 버전과 폴백 전략을 확인하세요.]]

### 8.1 외부 종속성

- [ ] 모든 외부 종속성이 식별됨
- [ ] 종속성에 대한 버전 관리 전략이 정의됨
- [ ] 중요한 종속성에 대한 폴백 접근 방식이 명시됨
- [ ] 라이선싱 영향이 다뤄짐
- [ ] 업데이트 및 패치 전략이 개요화됨

### 8.2 내부 종속성

- [ ] 컴포넌트 종속성이 명확히 매핑됨
- [ ] 빌드 순서 종속성이 다뤄짐
- [ ] 공유 서비스와 유틸리티가 식별됨
- [ ] 순환 종속성이 제거됨
- [ ] 내부 컴포넌트에 대한 버전 관리 전략이 정의됨

### 8.3 서드파티 통합

- [ ] 모든 서드파티 통합이 식별됨
- [ ] 통합 접근 방식이 정의됨
- [ ] 서드파티와의 인증이 다뤄짐
- [ ] 통합 실패에 대한 오류 처리가 명시됨
- [ ] 속도 제한과 할당량이 고려됨

## 9. AI 에이전트 구현 적합성

[[LLM: 이 아키텍처는 AI 에이전트에 의해 구현될 수 있습니다. 극도의 명확성을 염두에 두고 검토하세요. 패턴이 일관된가요? 복잡성이 최소화되었나요? AI 에이전트가 잘못된 가정을 할까요? 기억하세요: 명시적인 것이 암시적인 것보다 낫습니다. 명확한 파일 구조, 명명 규칙, 구현 패턴을 찾으세요.]]

### 9.1 AI 에이전트를 위한 모듈성

- [ ] 컴포넌트가 AI 에이전트 구현에 적절한 크기로 설계됨
- [ ] 컴포넌트 간 종속성이 최소화됨
- [ ] 컴포넌트 간 명확한 인터페이스가 정의됨
- [ ] 컴포넌트가 단일하고 잘 정의된 책임을 가짐
- [ ] 파일과 코드 조직이 AI 에이전트 이해에 최적화됨

### 9.2 명확성 & 예측가능성

- [ ] 패턴이 일관되고 예측 가능함
- [ ] 복잡한 로직이 더 간단한 단계로 분해됨
- [ ] 아키텍처가 지나치게 영리하거나 모호한 접근 방식을 피함
- [ ] 낯선 패턴에 대한 예시가 제공됨
- [ ] 컴포넌트 책임이 명시적이고 명확함

### 9.3 구현 가이던스

- [ ] 상세한 구현 가이던스가 제공됨
- [ ] 코드 구조 템플릿이 정의됨
- [ ] 특정 구현 패턴이 문서화됨
- [ ] 일반적인 함정이 솔루션과 함께 식별됨
- [ ] 도움이 될 때 유사한 구현에 대한 참조가 제공됨

### 9.4 오류 방지 & 처리

- [ ] 설계가 구현 오류 기회를 줄임
- [ ] 검증 및 오류 체크 접근 방식이 정의됨
- [ ] 가능한 곳에서 자가 치유 메커니즘이 통합됨
- [ ] 테스팅 패턴이 명확히 정의됨
- [ ] 디버깅 가이던스가 제공됨

## 10. 접근성 구현 [[FRONTEND ONLY]]

[[LLM: 백엔드 전용 프로젝트인 경우 이 섹션을 건너뛰세요. 접근성은 모든 사용자 인터페이스의 핵심 요구사항입니다.]]

### 10.1 접근성 표준

- [ ] 시맨틱 HTML 사용이 강조됨
- [ ] ARIA 구현 가이드라인이 제공됨
- [ ] 키보드 내비게이션 요구사항이 정의됨
- [ ] 포커스 관리 접근 방식이 명시됨
- [ ] 스크린 리더 호환성이 다뤄짐

### 10.2 접근성 테스팅

- [ ] 접근성 테스트 도구가 식별됨
- [ ] 테스트 프로세스가 워크플로우에 통합됨
- [ ] 컴플라이언스 목표 (WCAG 레벨)가 명시됨
- [ ] 수동 테스트 절차가 정의됨
- [ ] 자동화된 테스트 접근 방식이 개요화됨

[[LLM: 최종 검증 보고서 생성

체크리스트를 완료했으므로 다음을 포함하는 포괄적인 검증 보고서를 생성하세요:

1. 요약
   - 전체 아키텍처 준비성 (높음/중간/낮음)
   - 식별된 중요한 위험
   - 아키텍처의 주요 강점
   - 프로젝트 유형 (풀스택/프론트엔드/백엔드) 및 평가된 섹션

2. 섹션 분석
   - 각 주요 섹션의 통과율 (통과한 항목의 백분율)
   - 가장 우려되는 실패나 격차
   - 즉시 주의가 필요한 섹션
   - 프로젝트 유형으로 인해 건너뛴 섹션 참고

3. 위험 평가
   - 심각도별 상위 5개 위험
   - 각각에 대한 완화 권장사항
   - 문제 해결의 타임라인 영향

4. 권장사항
   - 개발 전 필수 수정 항목
   - 더 나은 품질을 위해 수정해야 할 항목
   - 개선되면 좋을 사항

5. AI 구현 준비성
   - AI 에이전트 구현에 대한 구체적인 우려사항
   - 추가 명확화가 필요한 영역
   - 다뤄야 할 복잡성 핫스팟

6. 프론트엔드 특정 평가 (해당하는 경우)
   - 프론트엔드 아키텍처 완전성
   - 주요 아키텍처와 프론트엔드 아키텍처 문서 간 정렬
   - UI/UX 사양 커버리지
   - 컴포넌트 설계 명확성

보고서를 제시한 후, 특히 경고나 실패가 있는 섹션의 상세 분석을 원하는지 사용자에게 물어보세요.]]
